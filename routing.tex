\chapter{Routing packets in large SpiNNaker machines}
	
	So far, this thesis has focused on tackling the practical challenges
	resulting from SpiNNaker's hexagonal torus network topology. In this chapter,
	I adjust my focus towards the practical challenges resulting from SpiNNaker's
	large scale. Faults in large systems are inevitable and in the half-million
	core, \num{28800} chip SpiNNaker machine recently completed at the University
	of Manchester, around \SI{1}{\percent} of chips exhibited faults\footnote{Of
	the faulty chips discovered, the vast majority of faults are attributed to a
	currently unknown SDRAM failure}. These faults result in gaps and broken
	links in the network topology which routing algorithms must avoid in order to
	ensure correct system operation.
	
	In this chapter I tackle the problem of extending existing routing algorithms
	for SpiNNaker's network to enable them to route-around known, static faults.
	Though dynamic or transient faults may also occur, in this work such faults
	are ignored and other techniques, such as protocol-level fault tolerance, are
	relied on instead.
	
	Numerous heuristic-based fault-tolerant routing algorithms exist which target
	different network topologies and router architectures. Unfortunately as I
	will show, these algorithms are not portable and rely on or attempt to work
	around specific features of their target network architecture. In particular,
	existing work is dominated by the challenge of developing routing schemes
	which avoid or defuse network deadlocks. Due to SpiNNaker's unconventional
	use of timeout-based flow-control, it is not subject to the routing
	restrictions present in other architectures intended to cope with deadlocks.
	
	In this chapter I introduce a graph-search based post-processing step for
	non-fault-tolerant routing algorithms which guarantees routability in
	SpiNNaker systems without disconnected subregions. I also demonstrate that
	this technique introduces both negligible computational overhead to the
	routing algorithm runtime and resulting network performance.
	
	TODO: NOTE THE FAULT RATES ENCOUNTERED IN PRACTICE...
	
	\section{Related work}
		
		Existing work on routing in SpiNNaker's network has ignored the challenge
		of avoiding faults and instead focused on producing efficient multicast
		routes. As a result this section is broken into two halves. In the first
		half I survey the existing non-fault-tolerant approaches to routing used in
		SpiNNaker to-date. In the second I discuss the approaches to fault tolerant
		routing taken in other systems.
		
		\subsection{Multicast routing in SpiNNaker}
			
			Various fault-intolerant multicast routing algorithms exist for many
			networks and a number have been proposed and evaluated specifically in the
			context of SpiNNaker.
			
			In 2012, Davies \emph{et al.} evaluated the use of three common torus
			routing algorithms in SpiNNaker and found that simple oblivious routing is
			suitable for typical neural applications \cite{davies12}. The three
			routing techniques are:
			
			\begin{description}
				
				\item[Dimension Order Routing (DOR)] Packets are routed along each
				dimension (e.g. $X$, $Y$ and $Z$) in turn until no further hops are
				available in that direction.  The order in which the dimensions are
				traversed is fixed.
				
				\item[Right Turn Only Routing (RTOR)] As in DOR except the dimension
				order is chosen such that routes only contain right-turns.
				
				\item[Longest Dimension First Routing (LDFR)] As in DOR except the
				dimension order is chosen in descending order of number of hops in each
				dimension.
				
			\end{description}
			
			These unicast routing techniques are converted into a multicast routing
			algorithm by merging together the routes produced between the source node
			and each destination node as illustrated in figure
			\ref{fig:simple-routers}.
			
			\begin{figure}
				\center
				\begin{subfigure}{0.3\linewidth}
					\center
					\buildfig{figures/simple-routers-dor.tex}
					
					\caption{DOR}
					\label{fig:simple-routers-dor}
				\end{subfigure}
				\begin{subfigure}{0.3\linewidth}
					\center
					\buildfig{figures/simple-routers-rtor.tex}
					
					\caption{RTOR}
					\label{fig:simple-routers-dor}
				\end{subfigure}
				\begin{subfigure}{0.3\linewidth}
					\center
					\buildfig{figures/simple-routers-ldfr.tex}
					
					\caption{LDFR}
					\label{fig:simple-routers-dor}
				\end{subfigure}
				
				\caption{Example multicast routes produced by merging together unicast
				routes from a central source node to each destination node.}
				\label{fig:simple-routers}
			\end{figure}
			
			In 2014, Navaridas \emph{et al.} introduced two new algorithms, `Enhanced
			Shortest Path Routing' (ESPR) and `Neighbourhood Exploring Routing' (NER)
			which produce multicast routing trees with fewer total hops
			\cite{navaridas14}. In both algorithms, routes are generated sequentially
			for each of the destinations of a route using LDFR. Unlike LDFR, however,
			these algorithms search a limited area of the network for other,
			already-connected destination nodes to which LDFR routes may be
			constructed. If no suitable destination is found, a LDFR route is
			constructed to the source node. Figure \ref{fig:search-regions} illustrates
			the shape of the searched regions of each algorithm. ESPR searches the
			trapezoidal region between the source and destination nodes while NER
			searches a fixed radius out from the destination node.
			
			\begin{figure}
				\center
				\begin{subfigure}{0.45\linewidth}
					\center
					\buildfig{figures/search-regions-espr.tex}
					
					\caption{ESPR}
					\label{fig:search-regions-espr}
				\end{subfigure}
				\begin{subfigure}{0.45\linewidth}
					\center
					\buildfig{figures/search-regions-ner.tex}
					
					\caption{NER}
					\label{fig:search-regions-espr}
				\end{subfigure}
				
				\caption{The ESPR and NER algorithms attempt to connect the node marked
				`D' to the closest node in the shaded region which is connected to the
				source node, `S'. If no connected node is found in the shaded region, the
				LDFR route is taken to `S'. The dotted line indicates the route chosen
				from `D'.}
				\label{fig:search-regions}
			\end{figure}
			
			Unfortunately none of these routing algorithms make any allowance for the
			avoidance of network faults. As a result their utility in real-world
			systems is limited.
		
		\subsection{Fault-tolerant routing}
			
			Numerous fault-tolerant routing algorithms have been proposed for
			super-computer networks. These algorithms are largely constrained by the
			need to maintain deadlock freedom. Since SpiNNaker's routers employ a
			timeout based deadlock-breaking strategy, much of this effort is
			unnecessary in SpiNNaker. As described below, this frequently renders
			existing fault-tolerant routing algorithms unnecessarily complex and
			inflexible.
			
			Deadlocks occur in a network if a cyclic dependency exists on any limited
			resource in the network. For example, as illustrated in figure
			\ref{fig:ring-deadlock}, in a ring network a deadlock may form when every
			node is waiting on the next node to accept a packet before accepting new
			packets from the previous node.
			
			\begin{figure}
				\center
				\buildfig{figures/ring-deadlock.tex}
				
				\caption{A deadlock in a ring network where each node is waiting for
				the next to accept a packet before accepting any further packets.}
				\label{fig:ring-deadlock}
			\end{figure}
			
			To prevent deadlocks, combinations of router microarchitectural features
			and routing restrictions may be employed. For example, a simple
			deadlock-free routing algorithm for mesh and torus networks mandates the
			use of DOR \cite{dally93}. Packets travelling in a -ve direction along
			each axis take priority over those travelling in a +ve direction. Packets
			travelling along the Y axis take priority over those travelling along the
			X dimension. Given these rules it is possible to define a total ordering
			on all hops in the network. Figure \ref{fig:deadlock-free-dor}
			illustrates a $3\times3$ mesh network whose hops have been numbered
			according to the total ordering defined above.  Any `X-then-Y' DOR route
			through this network results in the use of hops labelled with strictly
			increasing numbers. As a result, no cyclic dependencies (and thus no
			deadlocks) may occur.
			
			\begin{figure}
				\center
				\buildfig{figures/deadlock-free-dor.tex}
			
				\caption{Deadlock-free routing of two example routes using DOR in a 2D
				mesh topology. The numbers of the hops taken by each route are given on
				the right.}
				\label{fig:deadlock-free-dor}
			\end{figure}
			
			Unfortunately, the routing restrictions imposed to ensure deadlock
			freedom can result in fault-intolerant routing. In the example above, if
			the node at the bottom-right corner of the figure was faulty, the dotted
			example route would be blocked as no alternative routes are allowed.
			
			In practice, the routing rules used may be more relaxed, for example
			requiring that any route whose length is equal to a DOR must exist to
			guarantee routability \cite{rodrigo09}.
			
			Alternative routing strategies take a hybrid approach whereby an
			efficient but fault-intollerant routing algorithm is used where possible
			and in the presence of faults a less efficient but more robust strategy
			is employed. For example, the Immucube network architecture employs three
			virtual networks which operate independently over the same physical links
			\cite{puente07}. Initially messages are routed using a high-performance
			but potentially-deadlockable routing scheme in the first virtual network.
			If a deadlock is occurs, the deadlocked packet is dropped into the second
			virtual network in which packets are routed using a less efficient but
			deadlock-free but fault-intolerant routing algorithm. Finally, upon
			encountering a fault, packets are dropped onto the third virtual network
			which forms a ring network routing packets to every node in the network.
			
			Releated approaches \cite{mejia06,boppana95} divide the network into
			regions in which different routing rules are enforced to ensure deadlock
			freedom and, when required, fault tolerance.
			
			TODO FIGURE?
			
			The BlueGene/L supercomputer \cite{adiga02} uses DOR for its torus
			network and implements fault-tolerance by sacrificing otherwise
			functioning `lamb' nodes to ensure no route passes through a known dead
			link \cite{ho04}. In figure \ref{fig:lamb-nodes} an example scenario is
			shown where a single dead node is present and all nodes in the same row
			or column as the dead node have been made into lamb nodes. The lamb nodes
			may not be used in an application except as a through-route for other
			traffic. This pattern of lamb nodes guarantees that all dimension-order
			routes between all pairs of non-lamb nodes are not obstructed by the
			faulty node. This approach trades use of higher performance routing
			logic for wasted resources. This type of approach is most appropriate
			when algorithmic routing is used and routing rules are inflexible.
			
			\begin{figure}
				\center
				\buildfig{figures/lamb-nodes.tex}
				
				\caption{`Lamb' nodes may be disabled to ensure DOR will never
				encounter a fault.}
				\label{fig:lamb-nodes}
			\end{figure}
			
			Other algorithms proposed for the BlueGene architecture attempt to avoid
			the need for lamb nodes by generating routes which reach their destination
			via a `proxy' node \cite{gomez04}. By appropriately selecting the location
			of such a proxy, the existing routing algorithm used by the system can be
			guaranteed to select a route free of faults.
			
			TODO: EXAMPLE OF PROXY ROUTING TO AVOID FAULT
			
			Finally, many algorithms in in the field are distributed and use only local
			information along with limited information from their peers to generate
			routes \cite{fick09b}. In SpiNNaker, route generation is conventionally
			carried out centrally since no special on-chip hardware facilities exist
			for route generation. Centralised route generation also enables the routing
			algorithm to consider all available routes. As a result, there is little
			incentive for the use of distributed routing algorithms on SpiNNaker since
			global system information could be compactly shared for one-off routing
			passes.
			
			Algorithms for other architectures such as IP networks tend to be poor fits
			for static, regular network topologies since they use expensive graph-based
			algorithms for route discovery which aren't necessary here. They also tend
			to heavily feature graph topology discovery etc. which aren't needed here.
			
			Work on fault-tolerance in data centre networks does exploit the regularity
			of the network topology in routing algorithms \cite{guo08,liao12}.
			Unfortunately, the approaches used are not general enough to be applied to
			mesh-like topologies such as the one in SpiNNaker.
			
			Outside the field of computer networks, routing algorithms used to route
			wires across the surfaces of chips are required to solve similar problems
			to fault-tolerant network routing problems in mesh networks. Like mesh
			networks, the routes are defined within a regular Manhattan geometry and
			congested areas, rather than faults must be avoided by the algorithms
			\cite{kahng11}.  Unfortunately, these algorithms are designed for
			occasional batch operation prior to the multi-month process of chip
			manufacturing and so runtimes of hours or days are commonplace
			\cite{nam08}. As such these algorithms would be inappropriate for use
			with applications such as SpiNNaker where users' applications tend to be
			short-lived and thus routing should not be allowed to dominate runtime.
	
	\section{Partial graph search repair}
		
		In this section I introduce a novel post-processing algorithm, Partial
		Graph Search (PGS) repair, for routes produced by non-fault-tolerant
		routing algorithms.
		
		PGS repair guarantees routability for networks with no disconnected
		subregions by using a graph search algorithm to route around faults in the
		original route.  General-purpose graph search algorithms such as Breadth
		First Search (BFS), Dijkstra's Algorithm and A* are guaranteed to find
		shortest-path routes between pairs of points in arbitrary graphs. Such
		algorithms are generally a poor choice in highly regular network topologies
		such as meshes and toruses due to their high computational cost. In PGS
		repair, graph searching is only used for \emph{part} of the routing
		problem: to repair gaps in routes generated by more efficient routing
		algorithms.
		
		Real world super computer architectures are designed to ensure that faults
		are isolated \cite{gara05,alverson12} and thus tend to only impact a
		localised region of the network. Since PGS repair is only needed to route
		around these isolated faults, the space searched by the graph search
		algorithm should be very small in practice resulting in only short
		runtimes. In addition since faults are rare in real-world systems, the
		graph search process will only rarely be invoked.
		
		The PGS repair post-processing technique starts with a route produced by a
		non-fault-tolerant routing algorithm such as ESPR or NER. If this route is
		not obstructed by a fault, the algorithm terminates immediately without
		modifying the route. If the route attempts to use a faulty link, the
		algorithm proceeds as follows.
		
		The routing tree produced by the underlying routing algorithm is broken
		into subtrees wherever it attempts to route through a broken link and
		each subtree is assigned a unique colour, as illustrated in figure
		\ref{fig:pgs-repair-colouring}. From each disconnected subtree's root
		node in turn, a graph search is performed to find a short, fault-free
		route to a subtree node of a different colour. The subtree is then
		attached to the tree discovered by the graph search and re-coloured to
		match the tree it is connected to.
		
		\begin{figure}
			\center
			\begin{subfigure}{0.32\linewidth}
				\hspace*{-1.5em}
				\buildfig{figures/pgs-repair-colouring.tex}
				
				\caption{}
				\label{fig:pgs-repair-colouring}
			\end{subfigure}
			\begin{subfigure}{0.32\linewidth}
				\hspace*{-1.5em}
				\buildfig{figures/pgs-repair-colouring-fix1.tex}
				
				\caption{}
				\label{fig:pgs-repair-colouring-fix1}
			\end{subfigure}
			\begin{subfigure}{0.32\linewidth}
				\hspace*{-1.5em}
				\buildfig{figures/pgs-repair-colouring-fix2.tex}
				
				\caption{}
				\label{fig:pgs-repair-colouring-fix2}
			\end{subfigure}
			
			\caption{PGS repair process example showing a disconnected multicast
			route from A to B, C, D, E and F. $\times$ indicates a broken link.}
			\label{fig:pgs-repair-colouring-steps}
		\end{figure}
		
		For example in figure \ref{fig:pgs-repair-colouring-fix1} a path from the
		root of the subtree containing nodes E and F is found which connects it to
		the subtree rooted at A. Similarly in figure
		\ref{fig:pgs-repair-colouring-fix2} a path is also found connecting the
		subtree containing nodes C and D back to the subtree rooted at node A.
		
		If the routing tree was broken into $N+1$ subtrees by faults there will be
		$N$ subtrees disconnected from the root node. Each of the $N$ iterations of
		the algorithm connect a disconnected subtree to another subtree reducing
		the number of subtrees by $1$ each time. After $N$ iterations, therefore,
		exactly $1$ subtree remains which connects every node in the original
		routing tree without traversing faulty links.
		
		TODO: EXPLAIN THE FIDDLINESS HERE TO ENSURE WE DON'T CREATE LOOPS.
		
	\section{Evaluation \& Results}
		
		To assess the efficiency and effectiveness of the PGS repair technique,
		a number of experiments have been run.
		
		
		We generated routes for two standard traffic distributions: uniform as a
		worst-case and centroids as a "typical" case.
		
		\begin{figure}
			\center
			\buildfig{figures/traffic-distribution-centroids.tex}
			
			\caption{An example centroid distribution with four centroids. The
			$\times$ marks the location of the origin node. Lighter colours indicate
			greater likelihood of a connection.}
			\label{fig:traffic-distribution-centroids}
		\end{figure}
		
		We generated faults based on the assumption that hardware failures are
		likely uniform randomly distributed and can affect either chip-to-chip
		links or HSS links. We do not consider faults which disconnect nodes we
		plan to use since those nodes would never get booted in a real system and
		so we never need to route to them. Faults thus look like this:
		
		\begin{figure}
			\center
			\begin{subfigure}{0.48\linewidth}
				\hspace*{-1.5cm}
				\buildfig{figures/fault-example-uniform.tex}
				
				\caption{Uniform}
				\label{fig:fault-example-uniform}
			\end{subfigure}
			\begin{subfigure}{0.48\linewidth}
				\hspace*{-1.5cm}
				\buildfig{figures/fault-example-hss.tex}
				
				\caption{HSS Link}
				\label{fig:fault-example-hss}
			\end{subfigure}
			
			\caption{Fault models.}
			\label{fig:fault-example}
		\end{figure}
		
		We consider two representative general cases: one typical, one extreme in
		terms of fan-out and fault rate.
		
		\subsection{Baseline}
		
			We discover how many faults you hit when doing DOR, LPFR, ESPR and NER
			as a baseline. We find that as well as being better in other ways NER
			also inherently avoids some faults due to the NE thing. As a result
			we'll just look at NER from now-on.
			
			TODO: PLOTS
		
		\subsection{Heuristic performance}
			
			Not many faults remain but there are still some. Using DOR and zig-zag
			heuristics helps mop up some of these but still some remain.
			
			TODO: PLOTS
		
		\subsection{Runtime}
			
			Using PGS guarantees connectivity (if actually possible) but obviously
			uses graph search, at some expense, as overhead over existing
			algorithm... FGS is inherently fault tolerant but awfully slow so we
			quickly discount that. We can see that using a heuristic (and thus
			reducing usage of PGS) is good for performance but although
			statistically significant, the performance difference of [TODO: WORK OUT
			TINY PERCENTAGE] is not likely worth the trade off of greater code
			complexity on performance grounds alone.
			
			TODO: PLOTS
		
		\subsection{Route congestion}
			
			Unlike the heuristics above, PGS is guaranteed to increase the number
			of hops in a route to ensure connectivity. This in turn can cause
			congestion hot-spots. We generate a large number of random routes using
			our algorithms and compare congestion before and after PGS to see how
			it compares.
			
			TODO: COMPARE CONGESTION BEFORE AND AFTER PGS REPAIR
		
		\subsection{Routing table usage}
			
			No measured difference observed between approaches.
			
			TODO: MEASURE ROUTING TABLE USAGE
		
	\section{Conclusions}
		
		(PENDING CONGESTION RESULTS) As such, though the simple heuristics do
		provide a measurable improvement it is so small as to suggest the
		implementation effort is probably not worthwhile.
		
		Recommendation: use NEF and PGS repair since it is fast and works
		reliably on SpiNNaker.
