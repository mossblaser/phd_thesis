\chapter{Finding shortest path vectors in SpiNNaker's network}
	
	Once a SpiNNaker machine has been constructed as described in the previous
	chapter, its network forms a large hexagonal torus topology. To exploit this
	network routing algorithms must be used to generate routes for packets to
	follow between nodes. As well as ensuring that packets arrive at the correct
	destination, routing algorithms often attempt to produce routes which make
	efficient use of the network. This often involves attempting to reduce
	congestion by ensuring packets do not travel further through the network than
	absolutely necessary.
	
	Many popular routing algorithms for torus topologies, including all published
	algorithms designed for SpiNNaker's hexagonal torus topology
	\cite{davies12,navaridas14}, internally function by computing shortest path
	vectors and generating routes from them. Existing methods of calculating
	shortest path vectors in hexagonal torus topologies are unable to generate
	all possible shortest path vectors and, as a result, reduces the diversity of
	routes produced by routing algorithms, potentially worsening network
	contention.
	
	In this chapter I describe a novel technique for computing shortest path
	vectors in hexagonal torus topologies which yields \emph{all} possible
	shortest path vectors for any pair of nodes. Further, implementations of this
	new technique execute an order of magnitude faster than the existing
	alternatives.
	
	\section{Related work}
		
		DOR routes follow a shortest-path from source to destination following one
		dimensions then the next. For mesh topologies this requires computing a
		vector from the source to the sink and is straightforward:
		
		\subsection{Shortest path vectors and routing}
	
			A shortest path between two points in a torus topology is a sequence of
			`hops' between connected nodes which uses the minimum possible number of
			hops. Figure \ref{fig:shortest-paths} shows four paths between a pair of
			points in a (non-hexagonal) 2D torus topology. For the two points in the
			example, no path with fewer than five hops exists making all four examples
			`shortest paths'.
			
			\begin{figure}
				\center
				\begin{subfigure}[b]{0.24\linewidth}
					\center
					\buildfig{figures/shortest-paths-dor.tex}
					\caption{}
					\label{fig:shortest-paths-dor}
				\end{subfigure}%
				\begin{subfigure}[b]{0.24\linewidth}
					\center
					\buildfig{figures/shortest-paths-zig-zag.tex}
					\caption{}
					\label{fig:shortest-paths-zig-zag}
				\end{subfigure}%
				\begin{subfigure}[b]{0.24\linewidth}
					\center
					\buildfig{figures/shortest-paths-wrap-dor.tex}
					\caption{}
					\label{fig:shortest-paths-wrap-dor}
				\end{subfigure}%
				\begin{subfigure}[b]{0.24\linewidth}
					\center
					\buildfig{figures/shortest-paths-wrap-zig-zag.tex}
					\caption{}
					\label{fig:shortest-paths-wrap-zig-zag}
				\end{subfigure}%
				
				\caption{Shortest-paths between two points in a 2D torus topology.}
				\label{fig:shortest-paths}
			\end{figure}
			
			Shortest paths are typically generated in two steps. In the first step, a
			`shortest path vector' from the starting node to the destination node is
			computed. In the second step, a path is generated from this vector.
			
			In the example in figure \ref{fig:shortest-paths}, the vectors $(3, 2)$ and
			$(-3, 2)$ both describe the relationship between the bottom-left and
			top-right connected nodes. A `Manhattan' path is then constructed according
			to either of these vectors yields a shortest path. For example, figures
			\ref{fig:shortest-paths-dor} and \ref{fig:shortest-paths-zig-zag} show
			shortest paths built from the vector $(3, 2)$ and figures
			\ref{fig:shortest-paths-wrap-dor} and \ref{fig:shortest-paths-wrap-zig-zag}
			show shortest paths built from the vector $(-3, 2)$.
			
			Many simple but popular routing algorithms for torus topologies function by
			computing a shortest path vector from the source to destination node and
			then using a particular rule for generating a path from that vector. For
			example, 
	
		\subsection{Mesh Networks}
			
			TODO DESCRIBE MESH CALCULATION
			
			For hexagonal toruses, you have three dimensions but they aren't
			orthogonal... \cite{patel15}
		
		\subsection{Hexagonal Mesh Networks}
			
			TODO DESCRIBE HEX MESH CALCULATION
			
			For non-hexagonal toruses you just recenter everything and take the normal
			mesh vector. For hexagonal toruses this doesn't work.
		
		\subsection{Torus Networks}
			
			TODO DESCRIBE HEX TORUS CALCULATION NOT WORKING WHEN RECENTERING
		
		\subsection{Hexagonal Torus Networks}
		
			All known existing solutions perform this calculation by trying 12-possible
			DOR routes and picking the shortest. TODO: CITE SOME IMPLEMENTATIONS
			
			TODO DESCRIBE THE 12 ROUTES
			
			As we'll show later this mechanism is not very elegant/efficient and more
			importantly does not reveal all possible routes, e.g. those that spiral.
			
			TODO DESCRIBE SPIRAL ROUTES.
			
			TODO DESCRIBE RTOR AND LDFR.
		
	\section{Dimension order routing in hexagonal torus topologies}
		
		So, existing solutions have two problems: trying 12 options and picking one
		is a bit kludgey and there are actually more options than that.
		
		\subsection{Simpler minimal hexagonal torus vectors}
			
			If you redraw your route such that it is sourced from bottom left corner
			(which we'll now call (0, 0)), there are four possible ways this route
			could wrap.
			
			TODO: DESCRIBE WAYS OF WRAPPING
			
			For each of these wrappings, all the possible routes we can take are
			strictly limited in terms of the dimensions used since we're stuck in a
			corner.
			
			In each case, the function computing the minimal hex vector function
			simplifies to a much simpler operation.
			
			TODO: DESCRIBE MINIMUM VECTOR LENGTH FUNCTIONS FOR EACH CASE
			
			This gives us a cheap way to compute which of the four possible wrappings
			are shortest. Based on this we can pick one of at most two (is this
			easily provable?) vectors in some fair manner to reduce load. This vector
			can then be minimised in the usual way.
			
			This also leads to confirming a theoretical result giving the length of a
			shortest path in a hexagonal torus topology.
			
			TODO: DESCRIBE HOW TO GET LENGTH FUNCTION AND COMPARE WITH \cite{xiao04}
		
		\subsection{Generating spiralling routes}
			
			In non-hexagonal torus topologies the previous technique would reveal all
			possible shortest vectors (e.g. in cases where you can wrap more than one
			way). Unfortunately, due to the addition of a non-orthogonal axes,
			hexagonal toruses also have other cases when the width and height do not
			match.
			
			TODO: TORUS SPIRALLING EXAMPLE
			
			It is possible to calculate the maximum number of spirals thus:
			
			TODO: DESCRIBE HOW MAX NUMBER OF SPIRALS IS COMPUTED
			
			Given a number of spirals, the vector can be updated this (note that the
			change does not add a multiple of (1, 1, 1) but also does not result in
			the vector changing length and thus becoming non-minimal!).
			
			TODO: DESCRIBE TRANSFORMATION
			
			TODO: PROVE THAT MINIMALITY IS MAINTAINED
		
		\subsection{Proof of completeness}
		
			TODO: PROOF OF COMPLETENESS BY EXHAUSTIVE SEARCH
	
		\subsection{Conclusions}
			
			This approach is simpler, smaller, has sounder theoretical basis, and
			finds more routes than alternatives. This is good for load balancing and
			fault avoidance and also good for completeness.

